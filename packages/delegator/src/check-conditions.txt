import {
  LDfieldCondition,
  LDfieldConditionNonStatic,
  LDfieldSettings,
  LDfieldSettingsRecord
} from './types';

class GetFieldConditions<T extends string, Settings extends LDfieldSettingsRecord<T>> {
  private cache: {
    allowed: Record<string, boolean>,
    required: Record<string, boolean>,
  } = {
    allowed: {},
    required: {},
  }

  constructor(
    private settings: Settings,
    private props: Record<T, string>,
    ) {}
  
  check(fieldFor: T, restrictionType: 'allowed' | 'required'): boolean {
    if (fieldFor in this.cache[restrictionType]) {
      return this.cache[restrictionType][fieldFor];
    }
    const conditions = this.settings[fieldFor][restrictionType];
    if (typeof conditions === 'boolean') {
      return conditions;
    }
    return conditions.every(condition => {
      const { fieldFor } = condition;
      switch (condition.type) {
        case 'existance':
          // Field exists and field conditions are satisfied
          return fieldFor in this.props && this.check(fieldFor, restrictionType);
        case 'nonexistance':
          // Field does not exist and field conditions are not satisfied
          return !(condition.fieldFor in this.props) || !this.check(fieldFor, restrictionType);
        case 'in':
          // Value is in a set of values *and* the field is rendered
          return condition.options[this.props[fieldFor]] && this.check(fieldFor, restrictionType);
        default: {
          const type: never = condition;
          throw new Error(
            `Invalid condition type: ${condition}`,
          );
        }
      }
    })
  }
}

/**
 * Checks whether a specific condition is met
 * by the current props
 */
function check<T extends string, Settings extends LDfieldSettingsRecord<T>>(
  settings: Settings,
  { fieldFor }: LDfieldConditionNonStatic<T>,
  type: 'required' | 'allowed',
  props: Record<T, string>,
  cache: Record<T, boolean>
): boolean {
  return fieldFor in cache ?
    cache[fieldFor] :
    checkFieldConditions(
      settings,
      type,
      settings[fieldFor][type],
      props
    )
}

/**
 * Lazily checks field conditions
 */
class Checker<Settings extends LDfieldSettings> {
  private value?: boolean;
  
  constructor(
    private settings: Settings,
    private condition: LDfieldConditionNonStatic<Settings[number]['fieldFor']>,
    private type: 'required' | 'allowed',
    private props: Record<Settings[number]['fieldFor'], string>,
    ) {}

  get check(): boolean {
    if (typeof this.value === 'undefined') {
      this.value = check(this.settings, this.condition, this.type, this.props);
    }
    return this.value;
  }
}


 function checker(settings, conditions) {
  function 
}
 
/**
 * Checks whether an allowed/required condition holds true
 */
export function checkFieldConditions<Settings extends LDfieldSettings>(
  conditions: LDfieldCondition,
  // TODO: Make this stricter?
  props: Record<Settings[number]['fieldFor'], string>,
  settings: Settings,
  type: 'required' | 'allowed',
) {
  if (typeof conditions === 'boolean') {
    return conditions;
  }
  return conditions.every((condition) => {
    const checked = {
      get checked(): boolean {
        const internalConditions = settings.find(
          ({ fieldFor }) => condition.fieldFor === fieldFor,
        ).condition[type];
      }
    }
    
    
    
    switch (condition.type) {
      case 'existance':
        // Field exists and field conditions are satisfied
        return condition.fieldFor in props && check();
      case 'nonexistance':
        // Field does not exist and field conditions are not satisfied
        return !(condition.fieldFor in props) || !check();
      case 'in':
        // Value is in a set of values *and* the field is rendered
        return condition.options[props[condition.fieldFor]] && check();
      default: {
        const type: never = condition;
        throw new Error(
          `Invalid condition type: ${condition} ${JSON.stringify(condition)}`,
        );
      }
    }
  });
}
